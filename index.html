<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Railway Accident Prevention Simulator</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --danger:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; background:linear-gradient(180deg,#071028 0%, #081426 60%); color:#e6eef6}
    .app{display:grid; grid-template-columns:420px 1fr; gap:22px; padding:28px; height:100vh; box-sizing:border-box}
    .panel{background:var(--card); border-radius:12px; padding:18px; box-shadow:0 8px 24px rgba(2,6,23,0.6);}    
    h1{font-size:18px; margin:0 0 12px 0}
    .controls{display:flex; flex-direction:column; gap:12px}
    label{font-size:13px; color:var(--muted)}
    .row{display:flex; gap:10px; align-items:center}
    input[type=range]{width:100%}
    .value{min-width:72px; text-align:right; font-weight:600}
    button{background:var(--accent); color:#042027; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; font-weight:700}
    .small{font-size:12px}
    .sim-area{display:flex; flex-direction:column; gap:12px}
    .track-wrap{background:linear-gradient(90deg,#071428 0%, #082033 100%); border-radius:10px; padding:18px; height:420px; position:relative; overflow:hidden}
    svg{width:100%; height:100%}
    .dashboard{display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin-top:10px}
    .stat{background:var(--glass); border-radius:8px; padding:10px; text-align:center}
    .stat .num{font-size:20px; font-weight:800}
    .legend{display:flex; gap:8px; align-items:center}
    .led{width:10px; height:10px; border-radius:50%}
    .green{background:#22c55e} .yellow{background:#f59e0b} .red{background:#ef4444}
    footer{font-size:12px; color:var(--muted); margin-top:6px}
    /* responsive */
    @media(max-width:980px){.app{grid-template-columns:1fr; height:auto; padding:16px} .track-wrap{height:300px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>ðŸš† Railway Accident Prevention Simulator</h1>
      <div class="controls">
        <div>
          <label>1) Train speed (km/h)</label>
          <div class="row">
            <input id="speed" type="range" min="10" max="200" value="100" step="1">
            <div class="value" id="speedVal">100 km/h</div>
          </div>
        </div>

        <div>
          <label>2) Obstacle distance from sensor (meters)</label>
          <div class="row">
            <input id="distance" type="range" min="5" max="500" value="150" step="1">
            <div class="value" id="distVal">150 m</div>
          </div>
        </div>

        <div>
          <label>3) Sensor detection delay (ms)</label>
          <div class="row">
            <input id="sensorDelay" type="range" min="0" max="1000" value="150" step="10">
            <div class="value" id="delayVal">150 ms</div>
          </div>
        </div>

        <div>
          <label>4) Braking deceleration (m/sÂ²)</label>
          <div class="row">
            <input id="brake" type="range" min="0.5" max="5" value="1.5" step="0.1">
            <div class="value" id="brakeVal">1.5 m/sÂ²</div>
          </div>
        </div>

        <div>
          <label class="small">Simulation Controls</label>
          <div class="row">
            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn" style="background:#1f2937;color:#e6eef6">Reset</button>
            <div style="flex:1"></div>
            <div class="legend small"><div class="led green"></div> Safe <div style="width:10px"></div> <div class="led red"></div> Danger</div>
          </div>
        </div>

        <div class="panel small" style="background:transparent; padding:0; box-shadow:none">
          <p class="small">Instructions: adjust speed, obstacle distance, sensor delay, and braking deceleration. Hit <strong>Start Simulation</strong>. The simulator calculates detection time, stopping distance, shows auto-brake trigger, and animates the train and obstacle.</p>
        </div>
      </div>
    </div>

    <div class="panel sim-area">
      <div class="track-wrap" id="trackWrap">
        <!-- SVG scene -->
        <svg id="scene" viewBox="0 0 1200 500" preserveAspectRatio="xMidYMid meet">
          <!-- Ground / tracks -->
          <rect x="0" y="360" width="1200" height="120" fill="#071428" />
          <g id="tracks">
            <rect x="0" y="380" width="1200" height="8" fill="#263238" />
            <!-- sleepers -->
            <g id="sleepers"></g>
          </g>

          <!-- Obstacle (red box) -->
          <g id="obstacle" transform="translate(900,300)">
            <rect x="-20" y="-20" width="40" height="40" rx="6" fill="#b91c1c" stroke="#7f1d1d" stroke-width="2"></rect>
            <text x="0" y="40" font-size="12" text-anchor="middle" fill="#ffdede">Obstacle</text>
          </g>

          <!-- Sensor (on track) -->
          <g id="sensor" transform="translate(300,340)">
            <rect x="-8" y="0" width="16" height="24" fill="#94a3b8" rx="3"/>
            <circle cx="0" cy="-6" r="6" fill="#60a5fa"/>
            <text x="0" y="44" font-size="12" text-anchor="middle" fill="#9fb4c8">Sensor</text>
          </g>

          <!-- Train group (SVG car) -->
          <g id="train" transform="translate(100,300)">
            <rect x="-80" y="-40" width="160" height="48" rx="10" fill="#0ea5a4"></rect>
            <rect x="-60" y="-60" width="40" height="20" rx="4" fill="#075985"></rect>
            <rect x="20" y="-60" width="40" height="20" rx="4" fill="#075985"></rect>
            <circle cx="-40" cy="10" r="12" fill="#111827"></circle>
            <circle cx="40" cy="10" r="12" fill="#111827"></circle>
            <text x="0" y="6" font-size="12" text-anchor="middle" fill="#e6eef6">TRAIN</text>
            <!-- brake lights -->
            <rect id="brakeLight" x="64" y="-22" width="10" height="10" rx="3" fill="#ef4444" opacity="0"></rect>
          </g>

          <!-- warning line at sensor -->
          <line id="sensorLine" x1="300" y1="260" x2="300" y2="380" stroke="#60a5fa" stroke-width="2" stroke-dasharray="4 4"/>

          <!-- stopping distance line (dynamic) -->
          <line id="stopLine" x1="0" y1="250" x2="0" y2="250" stroke="#f97316" stroke-width="3" opacity="0"/>

          <!-- overlay text -->
          <g id="overlayText"></g>
        </svg>
      </div>

      <div class="dashboard">
        <div class="stat">
          <div class="small">Sensor Status</div>
          <div class="num" id="sensorStatus">Idle</div>
        </div>
        <div class="stat">
          <div class="small">Time to Detect</div>
          <div class="num" id="timeDetect">0.00 s</div>
        </div>
        <div class="stat">
          <div class="small">Calculated Stopping Distance</div>
          <div class="num" id="stopDist">0.0 m</div>
        </div>
      </div>
      <footer>Physics used: speed (m/s), deceleration (m/sÂ²). Stopping distance = vÂ² / (2*a). Detection triggers after sensor delay + travel time to sensor.</footer>
    </div>
  </div>

  <script>
    // --- Utilities ---
    const qs = s=>document.querySelector(s);
    const speedEl = qs('#speed'); const speedVal = qs('#speedVal');
    const distEl = qs('#distance'); const distVal = qs('#distVal');
    const delayEl = qs('#sensorDelay'); const delayVal = qs('#delayVal');
    const brakeEl = qs('#brake'); const brakeVal = qs('#brakeVal');
    const startBtn = qs('#startBtn'); const resetBtn = qs('#resetBtn');
    const train = qs('#train'); const obstacle = qs('#obstacle'); const sensor = qs('#sensor');
    const sensorStatus = qs('#sensorStatus'); const timeDetect = qs('#timeDetect'); const stopDistEl = qs('#stopDist'); const brakeLight = qs('#brakeLight');
    const scene = qs('#scene'); const stopLine = qs('#stopLine'); const overlayGroup = qs('#overlayText');

    // Map logical meters to SVG coordinates (scale)
    const svgWidth = 1200; const sensorX = 300; // sensor fixed x in svg coords
    // We'll map -300..800 meters to sensor..scene end
    const metersSpan = 1100; // -300 .. +800
    const pxSpan = 900; // how many px correspond to 1100 meters
    const pxPerMeter = pxSpan / (metersSpan - 0); // px per meter

    const metersToPx = (m)=>{
      // sensor at 0 meters -> sensorX px
      return sensorX + (m * pxPerMeter);
    }

    // initialize sleepers for visual track
    (function makeSleepers(){
      const sleepers = qs('#sleepers');
      for(let x=0;x<1200;x+=24){
        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x',x); rect.setAttribute('y',384); rect.setAttribute('width',12); rect.setAttribute('height',12); rect.setAttribute('fill','#2b3942');
        sleepers.appendChild(rect);
      }
    })();

    // Update labels when sliders change
    function updateLabels(){
      speedVal.textContent = speedEl.value + ' km/h';
      distVal.textContent = distEl.value + ' m';
      delayVal.textContent = delayEl.value + ' ms';
      brakeVal.textContent = parseFloat(brakeEl.value).toFixed(1) + ' m/sÂ²';
      // move obstacle based on dist
      const px = metersToPx(parseFloat(distEl.value));
      obstacle.setAttribute('transform','translate(' + px + ',300)');
    }
    [speedEl, distEl, delayEl, brakeEl].forEach(i=>i.addEventListener('input', updateLabels));
    updateLabels();

    // Simulation state
    let animReq = null; let simRunning=false;
    // We'll place train's logical position in meters relative to sensor negative -> train behind sensor
    let trainPos = -200; // meters behind sensor

    function resetSim(){
      if(animReq) cancelAnimationFrame(animReq);
      simRunning=false;
      trainPos = -200;
      setTrainPositionMeters(trainPos);
      sensorStatus.textContent='Idle'; timeDetect.textContent='0.00 s'; stopDistEl.textContent='0.0 m';
      brakeLight.style.opacity=0; stopLine.setAttribute('opacity',0);
      clearOverlay();
    }

    function setTrainPositionMeters(meters){
      // map meters to svg x directly
      const x = metersToPx(meters);
      train.setAttribute('transform','translate(' + x + ',300)');
    }

    // Physics functions
    function kmh_to_ms(kmh){return kmh/3.6}
    function stoppingDistance(v_ms, a){ // v^2/(2a)
      return (v_ms*v_ms)/(2*Math.max(0.0001,a));
    }

    // overlay helpers
    function clearOverlay(){
      while(overlayGroup.firstChild) overlayGroup.removeChild(overlayGroup.firstChild);
    }
    function updateOverlay(distanceToObstacle){
      // distanceToObstacle in meters (obstacleMeters - trainPos)
      clearOverlay();
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x',20);
      text.setAttribute('y',40);
      text.setAttribute('font-size',14);
      text.setAttribute('fill','#e6eef6');
      text.textContent = 'Distance to Obstacle: ' + (distanceToObstacle>0? distanceToObstacle.toFixed(1) + ' m' : '0.0 m');

      // speed readout
      const speedKmh = parseFloat(speedEl.value);
      const speedText = document.createElementNS('http://www.w3.org/2000/svg','text');
      speedText.setAttribute('x',20);
      speedText.setAttribute('y',60);
      speedText.setAttribute('font-size',12);
      speedText.setAttribute('fill','#9fb4c8');
      speedText.textContent = 'Speed: ' + speedKmh.toFixed(0) + ' km/h';

      g.appendChild(text); g.appendChild(speedText);
      overlayGroup.appendChild(g);
    }

    function startSimulation(){
      if(simRunning) return;
      simRunning=true;
      sensorStatus.textContent='Monitoring';
      const speedKmh = parseFloat(speedEl.value);
      const speedMs = kmh_to_ms(speedKmh);
      const obstacleMeters = parseFloat(distEl.value); // distance from sensor ahead
      const sensorDelayMs = parseFloat(delayEl.value);
      const a = parseFloat(brakeEl.value);

      // initial train position: trainPos meters behind sensor
      trainPos = -200; // start 200m behind sensor
      setTrainPositionMeters(trainPos);

      // handle zero/very small speed
      const safeSpeedMs = Math.max(0.0001, speedMs);

      // detection time after start (simple model: sensor detects immediately after sensorDelay)
      const detectionTime = sensorDelayMs/1000; // seconds after start

      // stopping distance when brakes fully applied
      const stopDist = stoppingDistance(safeSpeedMs, a);

      // Update dashboard numbers
      timeDetect.textContent = detectionTime.toFixed(2) + ' s';
      stopDistEl.textContent = stopDist.toFixed(1) + ' m';

      // animate stopLine
      const stopLineMetersFromSensor = obstacleMeters - stopDist;
      const stopLineX = metersToPx(stopLineMetersFromSensor);
      stopLine.setAttribute('x1', stopLineX); stopLine.setAttribute('x2', stopLineX); stopLine.setAttribute('y1',240); stopLine.setAttribute('y2',380); stopLine.setAttribute('stroke','#f97316'); stopLine.setAttribute('opacity',1);

      // decide if collision occurs: if stopping distance >= gapAtBrake (we'll evaluate dynamically)

      // Visual sensor pulse after delay
      setTimeout(()=>{
        sensorStatus.textContent = 'Obstacle Detected';
        pulseSensor();
      }, sensorDelayMs);

      // anchor time
      const startTimestamp = performance.now(); let lastTs = null; let braking=false; let brakeStartTime=null;

      function step(ts){
        if(!lastTs) lastTs = ts; const dt = (ts - lastTs)/1000; lastTs = ts;
        const animElapsed = (ts - startTimestamp)/1000;

        // trigger braking after detectionTime
        if(!braking && animElapsed >= detectionTime){
          braking = true; brakeStartTime = animElapsed; sensorStatus.textContent = 'Braking'; brakeLight.style.opacity = 1;
        }

        // update position
        if(!braking){
          trainPos += safeSpeedMs * dt;
        } else {
          const tSinceBrake = animElapsed - brakeStartTime;
          const vNow = Math.max(0, safeSpeedMs - a * tSinceBrake);
          trainPos += vNow * dt;
        }

        setTrainPositionMeters(trainPos);

        // compute distance from train nose to obstacle
        const noseToObstacle = obstacleMeters - trainPos;
        updateOverlay(noseToObstacle);

        // collision check
        if(trainPos >= obstacleMeters){
          sensorStatus.textContent = 'Collision!';
          brakeLight.style.opacity = 1;
          flashObstacle();
          simRunning = false;
          return;
        }

        // stopped check
        if(braking){
          const vNow = Math.max(0, safeSpeedMs - a * (animElapsed - brakeStartTime));
          if(vNow <= 0.1){
            // evaluate whether stopped before obstacle
            const stoppedGap = obstacleMeters - trainPos;
            const stoppedSafe = stoppedGap > 0.5; // small buffer
            sensorStatus.textContent = stoppedSafe ? 'Stopped (Safe)' : 'Stopped (Collision)';
            simRunning = false;
            return;
          }
        }

        if(simRunning) animReq = requestAnimationFrame(step);
      }

      animReq = requestAnimationFrame(step);
    }

    // helper pulses and visuals
    function pulseSensor(){
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx',sensorX); circle.setAttribute('cy',320); circle.setAttribute('r',8); circle.setAttribute('fill','#60a5fa'); circle.setAttribute('opacity',0.6);
      scene.appendChild(circle);
      let t=0; const dur=700; const initialR=8;
      function p(ts){
        t += 16; const frac = t/dur; circle.setAttribute('r', initialR + frac*80); circle.setAttribute('opacity', Math.max(0,0.6*(1-frac)));
        if(t < dur) requestAnimationFrame(p); else circle.remove();
      }
      requestAnimationFrame(p);
    }

    function flashObstacle(){
      const rect = obstacle.querySelector('rect');
      let flashes=0; const maxFlashes=6; const intv=120;
      const id = setInterval(()=>{
        rect.setAttribute('fill', flashes%2? '#b91c1c' : '#fff'); flashes++;
        if(flashes>maxFlashes){ clearInterval(id); rect.setAttribute('fill','#b91c1c'); }
      }, intv);
    }

    // Button wiring
    startBtn.addEventListener('click', ()=>{ startSimulation(); });
    resetBtn.addEventListener('click', resetSim);

    // init
    resetSim();
  </script>
</body>
</html>
